{"version":3,"sources":["utils.js"],"names":["slice","arr","idx","len","calculateChecksum","message","calculatedSum","lastIdx","length","i","checksum","checkSum","data","isValidInComingMessage","msgLength","payloadType","getPayloadType","Buffer","from","isValidHeaderBytes","Constants","PAYLOAD_TYPE_UNKNOWN","isValidEndBytes","equals","getPayloadByStrip0D0A","parsePayload","payload","IDX","START_BYTES","MAC_1","MAC_2","DATA_PAYLOAD","PAYLOAD_FAFB_TYPE_DEVICE_REGISTRATION","mac1","toString","mac2","PAYLOAD_FCFD_TYPE_DATA","dataPayload","parseDataPayload","parserType","type","readUInt32LE","readUInt8","val1","val2","val3","batt","nameLen","name","parseInt","startBytes","createBufferFromHexString","hexChar","b","hexFromChar","c","charCodeAt","UInt32LEByte","val","buff","allocUnsafe","writeUInt32LE","input"],"mappings":"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","file":"utils.js","sourcesContent":["/** * Created by nat on 7/5/2017 AD.\n */\n\nexport const slice = (arr, idx, len) => {\n  return arr.slice(idx, idx + len)\n}\n\nexport let calculateChecksum = (message) => {\n  let calculatedSum = 0\n  let lastIdx = message.length\n  for (let i = 0; i < lastIdx; i++) {\n    calculatedSum ^= message[i]\n  }\n  return calculatedSum\n}\n\nexport let checksum = (message) => {\n  let checkSum = message[message.length - 1]\n  let data = slice(message, 0, message.length - 1)\n  let calculatedSum = calculateChecksum(data)\n  return calculatedSum === checkSum\n}\n\n/*\n * valid is\n *    startwith 0xfc, 0xfd\n *    endwith 0x0d 0x0a\n */\nexport let isValidInComingMessage = (message) => {\n  const msgLength = message.length\n\n  const payloadType = getPayloadType(Buffer.from(message))\n  const isValidHeaderBytes = payloadType !== Constants.PAYLOAD_TYPE_UNKNOWN\n  const isValidEndBytes = slice(message, msgLength - 2, 2).equals(Buffer.from([0x0d, 0x0a]))\n\n  return isValidHeaderBytes && isValidEndBytes\n}\n\nexport let getPayloadByStrip0D0A = (message) => {\n  if (isValidInComingMessage(message)) {\n    return message.slice(message, message.length - 2)\n  } else {\n    return null\n  }\n}\n\nexport let parsePayload = (payload) => {\n  // START BYTE = 2 BYTES\n  // MAC ADDR   = 6 BYTES\n  // DATA LEN   = 1 BYTES\n  const IDX = {\n    START_BYTES: 0,\n    MAC_1: 2,\n    MAC_2: 2 + 6,\n    DATA_PAYLOAD: 2 + 6 + 6 + 1\n  }\n\n  const payloadType = getPayloadType(payload)\n\n  if (payloadType === Constants.PAYLOAD_FAFB_TYPE_DEVICE_REGISTRATION) {\n    // const type = payload.slice(2, 6)\n    const mac1 = slice(payload, IDX.MAC_1 + 4, 6).toString('hex')\n    const mac2 = slice(payload, IDX.MAC_2 + 4, 6).toString('hex')\n    // mac1 = SOFT_AP_IF\n    // mac2 = STA_IF\n    return {mac1, mac2, payloadType}\n  } else if (payloadType === Constants.PAYLOAD_FCFD_TYPE_DATA) {\n    const mac1 = slice(payload, IDX.MAC_1, 6).toString('hex')\n    const mac2 = slice(payload, IDX.MAC_2, 6).toString('hex')\n    const len = payload[2 + 6 + 6]\n    const dataPayload = slice(payload, IDX.DATA_PAYLOAD, len)\n    return {len, mac1, mac2, data: dataPayload, payloadType}\n  } else {\n    return {\n      payloadType\n    }\n  }\n}\n\nexport let parseDataPayload = (payload, parserType) => {\n  // console.log(`parseDataPayload = `, typeof payload, payload, payload.toString('hex'))\n  if (parserType === Constants.PAYLOAD_FCFD_TYPE_DATA) {\n    const type = payload.slice(2, 6)\n    const [val1, val2, val3, batt, nameLen] = [\n      payload.readUInt32LE(6) || 0,\n      payload.readUInt32LE(10) || 0,\n      payload.readUInt32LE(14) || 0,\n      payload.readUInt32LE(18) || 0,\n      payload.readUInt8(22)\n    ]\n\n    const name = slice(payload, 23, nameLen)\n    return {\n      type: type.toString('hex'),\n      val1: parseInt(val1.toString(), 10),\n      val2: parseInt(val2.toString(), 10),\n      val3: parseInt(val3.toString(), 10),\n      batt: parseInt(batt.toString(), 10),\n      name: name.toString()\n    }\n  } else if (parserType === Constants.PAYLOAD_FAFB_TYPE_DEVICE_REGISTRATION) {\n    // console.log(`parserType = DEVICE REGISTRATION`)\n  } else {\n    // console.log(`parserType = UNKNOWN`)\n  }\n}\n\nexport const getPayloadType = (payload) => {\n  const startBytes = slice(payload, 0, 2)\n  if (startBytes.equals(createBufferFromHexString('fafb'))) {\n    return Constants.PAYLOAD_FAFB_TYPE_DEVICE_REGISTRATION\n  } else if (startBytes.equals(createBufferFromHexString('fcfd'))) {\n    return Constants.PAYLOAD_FCFD_TYPE_DATA\n  } else {\n    return Constants.PAYLOAD_TYPE_UNKNOWN\n  }\n}\n\nexport const hexChar = (b) => b.toString(16)\nexport const hexFromChar = (c) => c.charCodeAt(0)\nexport const UInt32LEByte = (val) => {\n  const buff = Buffer.allocUnsafe(4)\n  buff.writeUInt32LE(val, 0)\n  return buff\n}\n\nexport const createBufferFromHexString = (input) => {\n  return Buffer.from(input, 'hex')\n}\n\nexport const Constants = {\n  PAYLOAD_FAFB_TYPE_DEVICE_REGISTRATION: 'PAYLOAD_FAFB_TYPE_DEVICE_REGISTRATION',\n  PAYLOAD_FCFD_TYPE_DATA: 'PAYLOAD_FCFD_TYPE_DATA',\n  PAYLOAD_TYPE_UNKNOWN: 'PAYLOAD_TYPE_UNKNOWN'\n}\n"],"sourceRoot":"/Users/nat/espnow_serial_bridge/espnow-mqtt/dist"}